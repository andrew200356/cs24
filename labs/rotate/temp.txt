
size_t Tree::find(const std::string &s) const {
    Node *current = root;
    size_t index = 0;

    // the code is triversal with in-order
    return f_inorder(current, s, index);
};

size_t Tree::f_inorder(Node *n, const std::string &s, size_t &index) const {
    if (n == nullptr) {
        // Item is not found (base case)
        return ~0;
    }
    size_t foundIndex = f_inorder(n->left, s, index);  // Search the left subtree
    size_t a = ~0;
    if (foundIndex != a) {
        // Item is found in the left subtree
        return foundIndex;
    }
    if (s == n->data) {
        // Item is equal to the n's data, item is found
        return index;
    }
    index++;                               // Increment the index after visiting a node
    return f_inorder(n->right, s, index);  // Search the right subtree
}

std::string Tree::lookup(size_t index) const {
    if (index >= root->weight) {
        throw std::out_of_range("Index out of range");
    }
    // althemetic trick to simply the calculation
    // since the index of the root item is the weight of its left subtree
    // we can simply the calculation by subtracting the weight of the left subtree
    size_t rootIndex = root->left == nullptr ? 0 : root->left->weight;

    if (index > rootIndex) {
        // the item is in the right subtree
        return nth_inorder(root->right, rootIndex + 1, index);
    } else if (index < rootIndex) {
        // the item is in the left subtree
        return nth_inorder(root->left, 0, index);
    } else {
        // the item is the root
        return root->data;
    }
};

std::string Tree::nth_inorder(Node *n, size_t index, size_t wanted) const {
    if (n == nullptr)
        return "";

    // first loop over the left subtree
    std::string left = nth_inorder(n->left, index, wanted);
    if (left != "") {
        return left;
    }

    // then check the middle
    if (index == wanted) {
        return n->data;
    }
    index++;

    // then loop over the right subtree
    return nth_inorder(n->right, index, wanted);
}




void Tree::removeRecursively(Node *&n, size_t index) {
    if (n == nullptr) {
        return;
    }

    // get the weight of the left subtree which is also the index of the root
    size_t leftWeight = n->left == nullptr ? 0 : n->left->weight;

    if (index < leftWeight) {
        // the item is in the left subtree
        removeRecursively(n->left, index);
        // update the weight of the current node, since the left subtree has item needs to be removed
        n->removeOne();
    } else if (index > leftWeight) {
        // the item is in the right subtree
        removeRecursively(n->right, index - leftWeight - 1);
        // update the weight of the current node, since the right subtree has item needs to be removed
        n->removeOne();
    } else {
        // the item is the root
        if (n->left == nullptr && n->right == nullptr) {
            // if the node is a leaf node, delete it
            delete n;
            n = nullptr;
        } else if (n->left == nullptr) {
            // if the node has only right child, replace the node with the right child
            Node *temp = n;
            n = n->right;
            delete temp;
        } else if (n->right == nullptr) {
            // if the node has only left child, replace the node with the left child
            Node *temp = n;
            n = n->left;
            delete temp;
        } else {
            // if the node has both left and right child
            // find the node n that contains the item at the next greater index
            Node *temp = n->right;
            while (temp->left != nullptr) {  // find the leftmost node of the right subtree
                temp->removeOne();
                temp = temp->left;
            }
            // swap the values of the two nodes
            n->data = temp->data;
            n->removeOne();
            // remove node n
            removeRecursively(n->right, index + 1);
        }
    }
};
